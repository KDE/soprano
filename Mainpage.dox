/**
 * \mainpage Soprano (aka QRDF) - A modular RDF storage framework
 *
 * Soprano is a QT-based pluggable framework for RDF storage and parsing. It tries to provide a highly usable
 * interface to several RDF storage solutions.
 *
 * \section quickstart Quickstart
 *
 * 1. Create an RDF Model:
 *
 * \code
 * Soprano::Model* model = Soprano::createModel();
 * \endcode
 *
 * 2. Fill it with statements:
 *
 * \code
 * model->addStatement( Soprano::Statement( QUrl( "http://mysite.org/data#A"), Soprano::RDFS::LABEL(), Soprano::LiteraValue( "A test resource" ) ) );
 * \endcode
 *
 * 3. Read the data back:
 *
 * \code
 * Soprano::StatementIterator it = model->listStatements();
 * while( it.next() ) {
 *    displayStatement( *it );
 * }
 * \endcode
 *
 *
 * \section contents Contents
 *
 * The following sections contain further information on the usage of %Soprano.
 *
 * \li \ref soprano_storage
 * \li \ref soprano_misc
 * \li \ref soprano_error_handling
 * \li \ref soprano_writing_plugins
 */


/**
 * \page soprano_storage RDF Storage
 *
 * The central class in Soprano is Soprano::Model which represents an RDF repository.
 * Model provides methods to add, remove, and list statements and to query the repository.
 *
 * The actual work is done by storage plugins (Soprano::Backend).
 *
 * Model instances are mostly created by the plugin implementations through the
 * Soprano::Backend::createModel() methods. In the most simple case one does not need to bother
 * with Soprano::Backend though as the basic methods are duplicated in the Soprano
 * namespace. Thus, to create a simple memory model using the default %Soprano backend:
 *
 * \code
 * Soprano::Model m = Soprano::createModel();
 * \endcode
 *
 * Finer grained control can be achieved by using the Backend directly:
 *
 * \code
 * Soprano::Backend* backend = Soprano::discoverBackendByName( "redland" );
 * Soprano::Model* model = backend->createModel();
 * \endcode
 *
 * %Soprano makes use of contexts, i.e. named graphs. Thus, statements as represented by
 * Soprano::Statement are actually RDF quadruples.
 *
 * For further details on Soprano::Model usage see the class and method documentation.
 */


/**
 * \page soprano_misc RDF Parsing and Serialization
 *
 * Apart from RDF storage %Soprano also supports parsing and serialization of RDF data. Both
 * tasks are handled through plugins which are based on Soprano::Parser and Soprano::Serializer.
 */


/**
 * \page soprano_error_handling Error handling in Soprano
 *
 * %Soprano tries to simulate exceptions through the usage of Soprano::Error::ErrorCache.
 *
 * Most methods in %Soprano classes have a means of reporting if an operation was successful or not. For additional error
 * information they inherit Soprano::Error::ErrorCache which provides the method Soprano::Error::ErrorCache::lastError().
 *
 * Thus, advanced error handling would look as follows:
 *
 * \code
 * Soprano::Model* model = Soprano::createModel();
 * Soprano::Statement invalidStatement;
 * if( model->addStatement( invalidStatement ) != Error::ERROR_NONE ) {
 *    showErrorMessage( model->lastError().message() );
 * }
 * \endcode
 *
 * For methods that do not return an immediate error status Soprano::Error::Error evalutes to a boolean. Thus, one can easily
 * check if an error occured as follows:
 *
 * \code
 * Soprano::StatementIterator it = model->listStatements();
 * while( it.next() ) {
 *    doSomething( *it );
 * }
 * if( it.lastError() ) {
 *    displayError( "Iteration failed: " + it.lastError().message() );
 * }
 * \endcode
 *
 * This has the same effect as checking for Soprano::Error::ERROR_NONE.
 *
 * This error handling is thread-safe. Thus, two threads can for example call methods of one Model at the same time
 * and still get proper Soprano::Error::Error instances back.
 */

/**
 * \page soprano_writing_plugins Writing Soprano Plugins
 *
 * %Soprano has five kinds of plugins: Soprano::Backend, Soprano::Parser, Soprano::Serializer,
 * Soprano::Query::Parser, and Soprano::Query::Serializer.
 *
 * Creating a new plugin for %Soprano is pretty easy. Image, for example, we want to write a new Backend plugin.
 * We simply create a class that inherits from QObject and the Soprano::Backend interface and
 * use the Q_INTERFACES macro to tell Qt's meta-object system about the new plugin. We then
 * export the plugin via the Q_EXPORT_PLUGIN2 macro in the source file.
 *
 * An example would look as follows:
 *
 * \code
 * class MyBackend : public QObject, public Soprano::Backend
 * {
 *    Q_OBJECT
 *    Q_INTERFACES(Soprano::Backend)
 *
 * public:
 *    StorageModel* createModel( const QStringList& options = QStringList() ) const;
 *    BackendFeatures supportedFeatures() const;
 * };
 * \endcode
 *
 * In the implementation file export the plugin so it can be picked up by the
 * plugin loading framework:
 *
 * \code
 * Q_EXPORT_PLUGIN2(soprano_mybackend, MyBackend)
 * \endcode
 *
 * The plugin then needs to be linked as a library and installed into the lib/soprano
 * target folder.
 *
 * All plugin interfaces inherit from Soprano::Error::ErrorCache for error handling and
 * subclasses should use Soprano::Error::ErrorCache::clearError()
 * and Soprano::Error::ErrorCache::setError() to report the status.
 */

/**
 * \page soprano_server Soprano Server
 *
 * %Soprano provides simple server and client librarys which allow for remote access to %Soprano models.
 *
 * \sa \ref soprano_server_protocol
 */

/**
 * \page soprano_server_protocol Soprano Server Protocol
 *
 * \warning The protocol described on this page is used internally by the Soprano server and client.
 * Normally there is no need to deal with it except if you want to write a client or server in another
 * programming language.
 *
 * The server protocol is quite simple and is based on a set of commands and binary serializations for
 * data types. It has been optimized for speed and nothing else so it always tries to comunicate as
 * little data as possible.
 *
 * \section soprano_server_protocol_commands Commands
 *
 * Commands are identified by unsigned 16bit integer values (native bit order). Issuing a command
 * is done by sending the command number followed by the command parameters.
 *
 * The following table lists the available commands.
 *
 * <table>
 * <tr><th>Command</th><th>Code</th><th>Parameters</th><th>Return values</th><th>Description</th></tr>
 * <tr><td>Create model</td><td>0x1</td><td>name (string), settings (List of #Soprano::BackendSetting)</td><td>model ID (unsigned 32bit int)</td><td>Retrieve the ID for a model (if the model does not yet exist, it is craeted.</td></tr>
 * </table>
 *
 * \section soprano_server_protocol_types Types
 *
 * The default implementation of the protocol uses QDataStream. Thus, all basic types are encoded as QDataStream does it.
 *
 * \subsection soprano_server_protocol_types_node Soprano::Node
 *
 * A %Soprano node starts with the node type encoded as unsigned 8bit. For the possible values see Soprano::Node::Type.
 * If it is a literal node (Soprano::Node::LiteralNode) after the type follow the literal value (Soprano::LiteralValue)
 * and the language (string). If it is a resource (Soprano::Node::ResourceNode) or blank node (Soprano::Node::BlankNode)
 * after the type follows the URI of the node (URI). If it is an empty node, nothing follows the type.
 *
 * \subsection soprano_server_protocol_types_statement Soprano::Statement
 *
 * A %Soprano statement is encoded simply by encoding the subject, predicate, object, and context node in that order.
 *
 * \subsection soprano_server_protocol_types_literalvalue Soprano::LiteralValue
 *
 * A %Soprano literal value is encoded as a QVariant: The type of the data (unsigned 32bit) (\sa QVariant::Type) followed
 * by a null flag (8bit) and the data of the specified type.
 *
 * \subsection soprano_server_protocol_types_bindingset
 */

// DOXYGEN_VERSION=4.0
// DOXYGEN_NAME=soprano
// DOXYGEN_ENABLE=YES
// DOXYGEN_SET_RECURSIVE = YES

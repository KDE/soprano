/**
 * \mainpage Soprano (aka QRDF) - A modular RDF storage framework
 *
 * Soprano is a QT-based pluggable framework for RDF storage and parsing. It tries to provide a highly usable
 * interface to several RDF storage solutions.
 *
 * \section quickstart Quickstart
 *
 * 1. Create an RDF Model:
 *
 * \code
 * Soprano::Model* model = Soprano::createModel();
 * \endcode
 *
 * 2. Fill it with statements:
 *
 * \code
 * model->addStatement( Soprano::Statement( QUrl( "http://mysite.org/data#A"), Soprano::Vocabulary::RDFS::label(), Soprano::LiteraValue( "A test resource" ) ) );
 * \endcode
 *
 * 3. Read the data back:
 *
 * \code
 * Soprano::StatementIterator it = model->listStatements();
 * while( it.next() ) {
 *    displayStatement( *it );
 * }
 * \endcode
 *
 *
 * \section contents Contents
 *
 * The following sections contain further information on the usage of %Soprano.
 *
 * \li \ref soprano_storage
 * \li \ref soprano_misc
 * \li \ref soprano_error_handling
 * \li \ref soprano_writing_plugins
 * \li \ref soprano_server
 */


/**
 * \page soprano_storage RDF Storage
 *
 * The central class in Soprano is Soprano::Model which represents an RDF repository.
 * Model provides methods to add, remove, and list statements and to query the repository.
 *
 * The actual work is done by storage plugins (Soprano::Backend).
 *
 * Model instances are mostly created by the plugin implementations through the
 * Soprano::Backend::createModel() methods. In the most simple case one does not need to bother
 * with Soprano::Backend though as the basic methods are duplicated in the Soprano
 * namespace. Thus, to create a simple memory model using the default %Soprano backend:
 *
 * \code
 * Soprano::Model m = Soprano::createModel();
 * \endcode
 *
 * Finer grained control can be achieved by using the Backend directly:
 *
 * \code
 * Soprano::Backend* backend = Soprano::discoverBackendByName( "redland" );
 * Soprano::Model* model = backend->createModel();
 * \endcode
 *
 * %Soprano makes use of contexts, i.e. named graphs. Thus, statements as represented by
 * Soprano::Statement are actually RDF quadruples.
 *
 * For further details on Soprano::Model usage see the class and method documentation.
 */


/**
 * \page soprano_misc RDF Parsing and Serialization
 *
 * Apart from RDF storage %Soprano also supports parsing and serialization of RDF data. Both
 * tasks are handled through plugins which are based on Soprano::Parser and Soprano::Serializer.
 */


/**
 * \page soprano_error_handling Error handling in Soprano
 *
 * %Soprano tries to simulate exceptions through the usage of Soprano::Error::ErrorCache.
 *
 * Most methods in %Soprano classes have a means of reporting if an operation was successful or not. For additional error
 * information they inherit Soprano::Error::ErrorCache which provides the method Soprano::Error::ErrorCache::lastError().
 *
 * Thus, advanced error handling would look as follows:
 *
 * \code
 * Soprano::Model* model = Soprano::createModel();
 * Soprano::Statement invalidStatement;
 * if( model->addStatement( invalidStatement ) != Error::ErrorNone ) {
 *    showErrorMessage( model->lastError().message() );
 * }
 * \endcode
 *
 * For methods that do not return an immediate error status Soprano::Error::Error evalutes to a boolean. Thus, one can easily
 * check if an error occured as follows:
 *
 * \code
 * Soprano::StatementIterator it = model->listStatements();
 * while( it.next() ) {
 *    doSomething( *it );
 * }
 * if( it.lastError() ) {
 *    displayError( "Iteration failed: " + it.lastError().message() );
 * }
 * \endcode
 *
 * This has the same effect as checking for Soprano::Error::ErrorNone.
 *
 * This error handling is thread-safe. Thus, two threads can for example call methods of one Model at the same time
 * and still get proper Soprano::Error::Error instances back.
 */

/**
 * \page soprano_writing_plugins Writing Soprano Plugins
 *
 * %Soprano has five kinds of plugins: Soprano::Backend, Soprano::Parser, Soprano::Serializer,
 * Soprano::Query::Parser, and Soprano::Query::Serializer.
 *
 * Creating a new plugin for %Soprano is pretty easy. Imagine, for example, we want to write a new Backend plugin.
 * We simply create a class that inherits from QObject and the Soprano::Backend interface and
 * use the Q_INTERFACES macro to tell Qt's meta-object system about the new plugin. We then
 * export the plugin via the Q_EXPORT_PLUGIN2 macro in the source file.
 *
 * An example would look as follows:
 *
 * \code
 * class MyBackend : public QObject, public Soprano::Backend
 * {
 *    Q_OBJECT
 *    Q_INTERFACES(Soprano::Backend)
 *
 * public:
 *    StorageModel* createModel( const QStringList& options = QStringList() ) const;
 *    BackendFeatures supportedFeatures() const;
 * };
 * \endcode
 *
 * In the implementation file export the plugin so it can be picked up by the
 * plugin loading framework:
 *
 * \code
 * Q_EXPORT_PLUGIN2(soprano_mybackend, MyBackend)
 * \endcode
 *
 * The plugin then needs to be linked as a library and installed into the lib/soprano
 * target folder.
 *
 * Finally we need to create a desktop file describing the plugin. The minimal desktop file
 * looks as follows (for details see \ref soprano_plugin_desktop_file):
 *
 * \code
 * [Desktop Entry]
 * Encoding=UTF-8
 * X-Soprano-Library=libsoprano_mybackend
 * X-Soprano-Version=2.0
 * Type=Service
 * ServiceTypes=Soprano/Backend
 * Name=MyBackend
 * Comment=My very cool and fast Soprano backend
 * \endcode
 *
 * The desktop file should be installed into share/soprano/plugins so the Soprano::PluginManager
 * will find it.
 *
 * All plugin interfaces inherit from Soprano::Error::ErrorCache for error handling and
 * subclasses should use Soprano::Error::ErrorCache::clearError()
 * and Soprano::Error::ErrorCache::setError() to report the status.
 */

/**
 * \page soprano_plugin_desktop_file Soprano Plugin Desktop Files
 *
 * Generic Desktop entries:
 * \code
 * [Desktop Entry]
 * Encoding=UTF-8
 * \endcode
 *
 * The name of the lib to load. This is the filename of the library without the extension.
 * \code
 * X-Soprano-Library=
 * \endcode
 *
 * Optional information about the plugin:
 *
 * \code
 * X-Soprano-Plugin-Author=
 * X-Soprano-Plugin-EMail=
 * X-Soprano-Plugin-Website=
 * X-Soprano-Plugin-License=
 * X-Soprano-Plugin-Version=
 * \endcode
 *
 * The soprano version this plugin has been written for.
 * The major version is the one that is important.
 * \code
 * X-Soprano-Version=
 * \endcode
 *
 * The type always needs to be set to "Service". ServiceTypes can be one of the following:
 * \li Soprano/Backend
 * \li Soprano/Parser
 * \li Soprano/Serializer
 * \li Soprano/QueryParser
 * \li Soprano/QuerySerializer
 *
 * \code
 * ServiceTypes=
 * Type=Service
 * \endcode
 *
 * The name of the plugin (human readable):
 * \code
 * Name=
 * \endcode
 *
 * An optional comment to further describe the plugin:
 * \code
 * Comment=
 * \endcode
 */

/**
 * \namespace Soprano::Vocabulary
 *
 * The vocabulary namespace contains static const QUrl objects for the most frequently
 * used ontology resources such as RDF or RDFS.
 *
 * Each member of this namespace is a namespace again which contains the resources for
 * one particular ontology. Linking to these namespaces is no overhead since the QUrl
 * objects are not created before the first usage. Thus, if an application for example
 * never uses any resource from the RDF namespace no memory will be allocated for its
 * members.
 */

// DOXYGEN_VERSION=4.0
// DOXYGEN_NAME=soprano
// DOXYGEN_ENABLE=YES
// DOXYGEN_SET_RECURSIVE = YES
